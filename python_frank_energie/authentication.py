# python_frank_energie/authentication.py

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional

import jwt
from .exceptions import AuthException

_LOGGER: logging.Logger = logging.getLogger(__name__)

@dataclass
class Authentication:
    """Authentication data.

    Generated by the login or renewToken mutation.

    authToken: The token to use for authenticated requests.
    refreshToken: The token to use to renew the authToken.
    """

    authToken: str
    refreshToken: str

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'Authentication':
        """Parse the response from the login or renewToken mutation."""
        _LOGGER.debug("Authentication %s", data)

        if errors := data.get("errors"):
            raise AuthException(errors[0]["message"])

        login_payload = data.get("data", {}).get("login")
        renew_payload = data.get("data", {}).get("renewToken")
        if not login_payload and not renew_payload:
            raise AuthException("Unexpected response")

        payload = Authentication._extract_payload(data)
        # if not payload:
        #     raise AuthException("Unexpected response")
        if not payload or "authToken" not in payload or "refreshToken" not in payload:
            raise AuthException("Unexpected response: Missing or incomplete payload")

        return Authentication(
            # authToken=payload.get("authToken"),
            # refreshToken=payload.get("refreshToken"),
            authToken=payload["authToken"],
            refreshToken=payload["refreshToken"]
        )

    def __init__(self, authToken: str, refreshToken: str):
        self.authToken = authToken
        self.refreshToken = refreshToken

    @staticmethod
    def _extract_payload(data: dict) -> Optional[dict]:
        """Extract the login or renewToken payload from the data dictionary."""
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")

    def authTokenValid(self, tz: timezone = timezone.utc) -> bool:
        """Return that authToken is valid according to expiration time."""
        authTokenDecoded = jwt.decode(
            self.authToken,
            verify=True,
            algorithms=["HS256"],
            options={"verify_signature": False},
        )
        return datetime.fromtimestamp(
            authTokenDecoded["exp"], tz=timezone.utc
        ) > datetime.now(tz=tz)

    def __repr__(self):
        return f"Authentication(authToken={self.authToken}, refreshToken={self.refreshToken})"

class AuthenticationResult:
    def __init__(self, authToken: str, refreshToken: str):
        self.authToken = authToken
        self.refreshToken = refreshToken